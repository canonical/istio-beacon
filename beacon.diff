diff --git a/lib/charms/istio_beacon_k8s/v0/service_mesh.py b/lib/charms/istio_beacon_k8s/v0/service_mesh.py
index 4139b71..39c3279 100644
--- a/lib/charms/istio_beacon_k8s/v0/service_mesh.py
+++ b/lib/charms/istio_beacon_k8s/v0/service_mesh.py
@@ -6,6 +6,8 @@
 The service mesh library is used to facilitate adding your charmed application to a service mesh.
 The library leverages the `service_mesh` and `cross_model_mesh` interfaces.
 
+##Consumer
+
 To add service mesh support to your charm, instantiate a ServiceMeshConsumer object in the
 `__init__` method of your charm:
 
@@ -34,13 +36,41 @@ try:
 except ops.TooManyRelatedAppsError as e:
     self.unit.status = BlockedStatus(e)
 ```
+
+You will then receive the labels which you need to add your product to the mesh:
+```
+def _on_mesh_relation_changed(self, event):
+    self._apply_labels to pods(self._mesh.labels())
+
+##Provider
+
+To provide a service mesh, instantiate the ServiceMeshProvider object in the __init__ method
+of your charm:
+```
+from charms.istio_beacon_k8s.v0.service_mesh import Policy, ServiceMeshProvider
+
+...
+self._mesh = ServiceMeshProvider(
+    charm = self,
+    labels = self._get_mesh_labels(),
+    mesh_relation_name = "service-mesh",
+)
+```
+
+The labels argument should be a dict containing the Kubernetes labels which the client charm needs
+to apply to join the mesh.
+
+You can then use the relation data to build your authorization policies:
+```
+self._build_authorization_policies(self._mesh.mesh_info())
+```
 """
 
 import enum
 import json
 import logging
 import re
-from typing import List, Optional
+from typing import Dict, List, Optional
 
 import pydantic
 from ops import CharmBase, Object
@@ -160,3 +190,50 @@ class ServiceMeshConsumer(Object):
         # This method currently assumes the namespace is the same as the model name. We
         # should consider if there is a better way to do this.
         return self._charm.model.name
+
+    def labels(self):
+        """Labels required for a pod to join the mesh."""
+        if self._relation is None:
+            return {}
+        return json.loads(self._relation.data[self._relation.app]["labels"])
+
+
+class ServiceMeshProvider(Object):
+    """Provide a service mesh to applications."""
+
+    def __init__(
+        self, charm: CharmBase, labels: Dict[str, str], mesh_relation_name: str = "service-mesh"
+    ):
+        """Class used to provide information needed to join the service mesh.
+
+        Args:
+            charm: The charm instantiating this object.
+            mesh_relation_name: The relation name as defined in metadata.yaml or charmcraft.yaml
+                for the relation which uses the service_mesh interface.
+            labels: The labels which related applications need to apply to use the mesh.
+        """
+        super().__init__(charm, mesh_relation_name)
+        self._charm = charm
+        self._relation_name = mesh_relation_name
+        self._labels = labels
+        self.framework.observe(
+            self._charm.on[mesh_relation_name].relation_created, self._relation_created
+        )
+
+    def _relation_created(self, _event):
+        self.update_relations()
+
+    def update_relations(self):
+        """Update all relations with the labels needed to use the mesh."""
+        rel_data = json.dumps(self._labels)
+        for relation in self._charm.model.relations[self._relation_name]:
+            relation.data[self._charm.app]["labels"] = rel_data
+
+    def mesh_info(self):
+        """Return the relation data used to define authorization policies on the mesh."""
+        mesh_info = []
+        for relation in self._charm.model.relations[self._relation_name]:
+            rel_data = json.loads(relation.data[relation.app]["mesh_data"])
+            rel_data["policies"] = [Policy.parse_obj(p) for p in rel_data["policies"]]
+            mesh_info.append(rel_data)
+        return mesh_info
diff --git a/src/charm.py b/src/charm.py
index 77a7132..b7d92c2 100755
--- a/src/charm.py
+++ b/src/charm.py
@@ -8,6 +8,7 @@
 import logging
 
 import ops
+from charms.istio_beacon_k8s.v0.service_mesh import ServiceMeshProvider
 
 logger = logging.getLogger(__name__)
 
@@ -17,6 +18,9 @@ class IstioBeaconCharm(ops.CharmBase):
 
     def __init__(self, *args):
         super().__init__(*args)
+
+        self._mesh = ServiceMeshProvider(self, labels=self.mesh_labels())
+
         self.framework.observe(self.on.start, self.on_start)
         self.framework.observe(self.on["service-mesh"].relation_changed, self.on_mesh_changed)
 
@@ -35,10 +39,14 @@ class IstioBeaconCharm(ops.CharmBase):
         manifest.
         """
         for relation in self.model.relations["service-mesh"]:
-            logger.error(relation.data[relation.app])
+            logger.error(self._mesh.mesh_info())
             # Update the mesh
         self.unit.status = ops.ActiveStatus()
 
+    def mesh_labels(self):
+        """Labels required for a workload to join the mesh."""
+        return {"foo": "bar"}
+
 
 if __name__ == "__main__":
     ops.main(IstioBeaconCharm)  # type: ignore
diff --git a/tox.ini b/tox.ini
index 1595490..ddad95d 100644
--- a/tox.ini
+++ b/tox.ini
@@ -27,15 +27,18 @@ pass_env =
 description = Apply coding style standards to code
 deps =
     black
+    ruff
 commands =
+    ruff check --fix {[vars]all_path}
     black {[vars]all_path}
 
 [testenv:lint]
 description = Check code against coding style standards
 deps =
     black
-    ruff
     codespell
+    pydantic
+    ruff
 commands =
     codespell {[vars]src_path}
     codespell {[vars]lib_path}
@@ -50,9 +53,10 @@ commands =
 [testenv:scenario]
 description = Run scenario tests
 deps =
-    pytest
-    ops-scenario
     coverage[toml]
+    ops-scenario
+    pydantic
+    pytest
     -r {tox_root}/requirements.txt
 commands =
     coverage run --source={[vars]src_path} \
